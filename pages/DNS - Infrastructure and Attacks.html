<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio Machine Gun</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">

    <!-- Custom Styles -->
    <link href="style.css" rel="stylesheet">

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Poppins" rel="stylesheet">

    <!-- Favicon -->
    <link rel="icon" href="images/logo.ico" />
</head>

<body class="container-fluid">

    <!-- Navigation -->
    <nav>
        <div class="dropdown">
            <button class="dropbtn">Details</button>
            <div class="dropdown-content">
                <a href="about.html"><div class="icon_text"><img src="images/about.png" width="20px" /></div>  About</a>
                <a href="contacts.html"><div class="icon_text"><img src="images/contacts.png" width="25px" /></div>  Contact</a>
                <a href="index.html"><div class="icon_text"><img src="images/blog.png" width="22px" /></div>  Blog</a>
            </div>
        </div>
    </nav>

    <!-- Header -->
    <header>
        <div class="title">
            <h1><strong>The tale of RADIUS</strong></h1>
            <h5>Remote Authentication Dial-In User Service</h5>

        </div>


    </header>

    <div class="greyish" style="text-align:center">
        <div class="row_project_page">
            <div class="textual_content">
                <div id="me">
                    <img id="my_picture" src="images/Me.png" />
                    <p><strong>Mr. Naraku</strong><br /><em>Unexpert Bosun </em><p>
                </div>


                <div id="date">1 May 2023</div>
                <p>
                    Can you imagine a world in which you would have to type every IP address for every website you want to visit?
                    Here, as a first step towards studying DNS security, we will try to understand how the Domain Name System infrastructure works, what are its main
                    vulnerabilities and how bad guys can exploit them. Later articles will instead focus on DNS fingerprinting and DNS network security practices. <br />

                </p>

                <div class="index">
                    <h5>Here's the <strong>contents</strong>:</h5>
                    <p></p>
                    <ul>
                        <li>
                            <a href="#bibliography">Bibliography and resources</a>

                        </li>
                        <li>
                            <a href="#part1">Understanding the Domain Name System</a>
                        </li>
                        <li>
                            <a href="#part2">DNS and Social Engineering</a>
                        </li>
                        <li>
                            <a href="#part3">DNS Cache Poisoning</a>
                        </li>
                        <li>
                            <a href="#part4">DNS Spoofing</a>
                        </li>
                        <li>
                            <a href="#part5">DDoS through DNS</a>
                        </li>
                    </ul>
                </div>

                <div class="biblio_box  ">


                    <h4 id="bibliography">Bibliography and resources</h4>
                    <p id="note">
                        The following content is inspired by the bibliographic resources cited below. <u>Purchase the material and support the authors</u>
                        to have a much more comprehensive and detailed understanding of any of the discussed topics.
                    </p>
                    <br />


                    <p>
                        <strong>DNS Security: Defending the Domain Name System</strong> <br />(1st Edition) by A. Liska, G. Stowe<br />
                        <strong><u><a href="https://www.amazon.com/DNS-Security-Defending-Domain-System-ebook/dp/B01H1SUZ8U">Purchase here</a></u></strong>
                    </p>
                    <hr class="black-line">
                    <p>
                        <strong>Comptia Network+ Certification All-In-One Exam Guide</strong> <br />(5th Edition (Exam N10-005)) by  M. Meyers <br />
                        <strong><u><a href="https://www.amazon.com/CompTIA-Network-Certification-Guide-N10-005/dp/0071789227">Purchase here</a></u></strong>
                    </p>


                </div>

                <hr>
                <br />
                <h3 class="titleh" id="part1">Understanding the Domain Name System</h3>

                <p>
                    The Domain Name System is one of the most important services in computer networking. In essence, DNS is a <strong>
                        redundant,
                        hierarchical, distributed database
                    </strong> used to exchange information about domain names.

                    We can metaphorically imagine the DNS hierarchy like some sort of <strong>tree</strong>. DNS has a root, and the various Top Level
                    Domains (TLDs) are similar to branches shooting off the root. Each TLD also leads to other smaller branches (Second Level Domains).
                    The leaves are Fully Qualified Domain Names (FQDNs), sometimes referred to as hostnames.<br /><br />

                </p>

                <h4><u>The root</u></h4>
                <p>
                    What we call “root” is actually a bunch (13, to be specific) of powerful servers dispersed around the
                    world collectively known as <strong>DNS root servers</strong>. Such servers are maintained by different organizations and
                    are on different networks. Note that, in reality, DNS is not relying on 13 physical servers, since each of
                    the operators deploys redundant computer equipment improving fault tolerance.
                </p>
                <p>
                    The internet name of the root computer team is <strong>"." (dot)</strong>. This is generally not displayed outside
                    the realm of DNS, but it is important to remember it is there. So, to properly point at the domain example.com
                    we should use the following representation: <em>    example.com.</em>

                </p>
                <p>
                    If the root name servers were taken down, all services relying on DNS would fail. Applications deploying mail,
                    FTP, and HTTP would quickly become unusable. For example, in 2007 a major DDoS attack temporarily crippled two
                    Root DNS servers. If you are curious, look <u><a href="https://en.wikipedia.org/wiki/2007_cyberattacks_on_Estonia">here</a></u>.
                </p>
                <p>
                    As you will see, DNS root servers have the <strong>complete and definitive name resolution table</strong>,
                    but most name resolution work is delegated to other DNS servers.<br /><br />
                </p>

                <h4><u>Top Level Domain</u></h4>
                <p>
                    Right below the DNS root in the hierarchy/tree there’s another set of DNS servers. They are called <strong>top-level domain</strong>
                    servers and they deal with what are known as the top-level domain (TLD) names. Each TLD server has its own root server(s).
                    We say that the root server is authoritative for information about the specific TLD. Examples of famous TLD names are <strong>
                        com, org, net, edu, gov
                    </strong>. TLD names are the last non empty label of a fully qualified domain name (FQDN). For example, in the domain name
                    www.example.com, the top-level domain is .com.
                </p>
                <p>
                    The top-level DNS servers delegate to thousands of <strong>second-level DNS servers</strong>. Second-level DNS servers support individual computers and handle
                    names like whitehouse .gov that have been created within each of the top-level domains. For example, in example.com, example is the second-level
                    domain of the .com TLD.
                    <br /><br />
                </p>

                <h4><u>DNS name space and Fully Qualified Domain Name</u></h4>
                <p>
                    The DNS name space pretty much works like a file system (like Windows’ NTFS or Linux’s ext3). It’s a hierarchy of domains
                    and host names organized into a tree-like. Each domain is like a folder, a holding space into which you can add computer names.
                    At the top of the tree is the root, to which all domains connect, just as the root directory in your file system is the holding
                    area for all your folders.
                </p>
                <p>
                    Individual host names (individual computer names) fit into domains. Each domain can then present subdomains, just as the folders
                    on your PC’s file system can have subfolders. You separate each domain from its subdomains with a period. Note that for DNS domain names and
                    host names only uppercase and lowercase letters (A–Z, a–z), numbers (0–9), and the hyphen (-) are admissible.
                </p>
                <p>
                    <br />
                    Let’s see <strong>an example</strong>. <br />Suppose to have your own little TCP/IP network for which you want to implement DNS. You will have to set up
                    one or more DNS servers as root for your private intranet. Given that such network is not connected to the internet, instead of
                    stuff like “.com” or “.net”, I can name domains whatever I want. My network has two domains: Apples and Bananas. Each domain will
                    then hold some subdomains, like you see in the figure. Within each subdomain, we’ll fit host names. Having two different domains allows
                    us to have two systems (one on each domain) with the same host name. It’s the same principle of naming two files with the same name in
                    different folders.
                </p>
                <div class="center figure">
                    <img src="images/DNS_04_23/DNS1.png" width="65%" />
                </div>

                <p>
                    A <strong>fully qualified domain name (FQDN)</strong> is a domain name that specifies an exact location in the DNS tree hierarchy.
                    A FQDN is written with the root on the extreme right, followed by the names of the domains and subdomain added in order onto the left until
                    we reach the host name, on the extreme left. Each name must be separated by period.
                </p>
                <p>
                    In our example, Jack.ServerX.Bananas. and Al.ServerX.Apples. are two instances of FQDN. As already mentioned, it’s common to drop the final dot,
                    given that all FQDNs will end up with one.
                </p>
                <p>
                    Similarly, if we consider the URL <strong><u>https://www.google.com</u></strong>, we notice the following:
                </p>
                <div class="center figure">
                    <img src="images/DNS_04_23/DNS2.png" width="75%" />
                </div>
                <p>
                    By observing the URL, we now have a much clearer vision of the DNS domain space. The same mechanism is extended to all URLs.
                </p>
                <div class="center figure">
                    <img src="images/DNS_04_23/DNS3.png" width="50%" />
                </div>

                <h4><u>Moving on...</u></h4>
                <p>
                    Ok… Now we can try to understand how to discover information about domain names and how organizations share information
                    about their own domain names. First let’s introduce some other concepts:
                </p>
                <ul>
                    <li>
                        <strong>Zones</strong>: A zone (zone file) is a list for a domain that gets filled with records. For instance, you can have the zone for .org, or the zone for wiki.org. Zones represent separate areas in the DNS namespace managed by a specific administrator. A DNS zone can contain multiple subdomains. Multiple zones can be physically placed in the same server.
                    </li>
                    <li>
                        <strong>Records</strong>: A record is a line in the zone data mapping an FQDN to an IP address. We are going to talk more about records later on.
                    </li>
                </ul>
                <br />
                <h4>
                    <u>
                        Recursive Name Servers:
                    </u>
                </h4>
                <p>
                    Recursive name servers or Recursive servers track down information about domains. They don’t know anything about the namespace, <strong>they simply ask questions</strong>. In fact, when someone asks something about a domain to the recursive server, the server turns around and asks the same question to another server, gets the answer and returns it to whomever was asking. Recursive servers can be placed on local or ISP’s networks. They can be assigned manually or through DHCP.
                </p>
                <br />
                <h4>
                    <u>
                        Authoritative Name Servers:
                    </u>

                </h4>
                <p>
                    Authoritative name servers <strong>store and share records about a domain name</strong>. Recursive servers query authoritative name servers to find answers to questions like “what is the IP Address of www.example.com?”. As already mentioned, these answers are then shared with other machines by the recursive name server. Authoritative name servers are registered with the TLD authority for which the administrator of the server intends to host domain names. So, to make it simple, a DNS authoritative name server for the domain has a zone containing records listing mapping all the host names on the domain to their corresponding IP addresses.
                </p>
                <p>
                    An authoritative name server can either be a <strong>primary (“master”)</strong> server or a <strong>secondary (“slave”)</strong> server. A primary server for a zone is the server that stores the definitive versions of all records in that zone (the zone file). A secondary server for a zone uses an automatic updating mechanism to pull an identical copy of the primary server's database for a zone. This process is known as zone transfer. Zone transfers are cool because they allow us to maintain only one single document, automating the replication of the changes we make to it.
                </p>
                <p>
                    So, to recap, a zone file is stored on the master name server; the slave name server retrieves a copy of such document and stores it locally. Recursive servers request information from the file, but they simply gather all the information the authoritative name server will share with them, without storing copies of the zone-file.
                </p><br />
                <h4>
                    <u>Name Resolution</u>

                </h4>
                <p>
                    In the early years of the Internet, DNS worked with IP addresses too. You could just type in the IP address of the server serving the webpage to access it. This involves two problems: (a) what if a server is in charge of serving many domain names for many different websites? (b) how can we memorize all the IP addresses for every website we need?
                </p>
                <p>
                    We have seen how domain names have solved the second issue. But still, when we type a web address into a web browser, the browser of a user needs to get the right IP address so to contact the corresponding webserver. By the way, when we convert a host name into an IP address, we talk about “<strong>forward lookup”</strong>. The other way around is known as “<strong>reverse lookup</strong>”.
                </p>
                <p>
                    Okay but… How does this work? Through some mechanism we call <strong>Name Resolution</strong>.
                </p>
                <p>
                    Let’s say we want to resolve the name <strong><u>www.example.com</u></strong>. The keyword is <strong>delegation</strong>. This is what happens:

                    <ol>
                        <li>
                            The host contacts its locally configured recursive DNS server and requests the IP address. Note that the host can contact such server because its IP address was acquired either through manual intervention or by DHCP.
                        </li>
                        <li>
                            The contacted recursive DNS server receives the request for the IP address of www.example.com and first checks a cache of previously resolved FQDNs to see if the name you are looking for is already there. If the server finds the name in the cache, it just gives back to the host the IP address.
                        </li>
                        <li>
                            If instead the server does not have an answer already memorized in its cache, it will contact the (authoritative) root servers, which know the addresses of the (authoritative) top-level domain DNS server in charge for “.com”.
                        </li>
                        <li>
                            The root servers send your DNS server an IP address for a .com server.
                        </li>
                        <li>
                            The local recursive DNS will now contact the TLD .com server, which unfortunately also doesn’t know the IP address for www.example.com but knows the one for the example.com DNS server.
                        </li>
                        <li>
                            The TLD .com server sends the IP address for example.com to your local recursive DNS server.
                        </li>
                        <li>
                            The (authoritative) example.com DNS server does know the IP address of www.example.com and can send that information back to the recursive local DNS server.
                        </li>
                        <li>
                            Your local DNS server first saves the received information in its cache, and then handles the IP data to your PC. Now your web browser knows what IP address to contact to fetch the webpage you want to visit.
                        </li>
                    </ol>
                    <br />
                    Important: All DNS queries are sent
                    <strong>over <u>port 53</u> using the User Datagram Protocol (UDP) </strong>.
                    See a scheme of the process here.
                </p>
                <div class="center figure">
                    <img src="images/DNS_04_23/DNS4.png" width="100%" />
                </div>


                <p>
                    To find information about DNS servers use the <em>ipconfig /all</em> command in Windows. <br />
                    Also notice that your computer also keeps a small cache of recently resolved FQDNs. To access it in Windows OS, use
                    <em>ipconfig /displaydns</em>.
                </p><br /><hr /><br />


                <h4><u>Resource records</u></h4>
                <p>
                    At the beginning of this page, we defined DNS as a fancy database used to exchange information about domain names. Let’s now focus on such information. All instances in the zone file that provide the information that users are looking for are called <strong>Resource Records (RR)</strong>. The whole point of DNS is moving RR around effectively.
                </p>
                <p>
                    The standard format for a RR consists of five fields, each containing specific information about the RR:
                </p>
                <div class="center figure">
                    <img src="images/DNS_04_23/DNS5.png" width="50%" />
                </div>

                <p>
                    <ul>
                        <li>
                            <strong>NAME</strong> - the FQDN or IP address (depending on the type of record) of the node in the tree.
                        </li>
                        <li>
                            <strong>TTL</strong> – TTL means Time to Live. If TTL = 24, for instance, when a website is transferred to a new server or you add a new URL to your server, it’ll take 24 hours for the changes to take effect. Notice that in the first line in the zone file the TTL (in seconds) is defined for the whole zones. This means that if the TTL of the single RR is not defined, the TTL at the beginning of the file zone will be used.
                        </li>
                        <li>
                            <strong>Class</strong> - For the sake of our conversation, the class will always be IN (Internet).
                        </li>
                        <li>
                            <strong>Type</strong> - Type defines the function of the RR. We’ll talk about this in a second.
                        </li>
                        <li>
                            <strong>Data</strong> - This field varies depending on the type of RR and it contains the data that the server is trying to share about the specific RR.
                        </li>
                    </ul>
                </p>
                <p>
                    Each RR serves a specific function. Many different types of RR exist, but here we focus on the most relevant ones.
                </p><br />
                <h4>
                    <u>(SOA) Start of Authority record</u>

                </h4>
                <p>
                    SOA is line 2 of the zone file. SOA contains administrative information about the zone and zone transfers. The SOA record defines the single DNS server in charge of the forward lookup zone. The SOA is the only RR that does not follow the standard format.
                    <ul>
                        <li>
                            The Domain itself
                        </li>
                        <li>
                            The Class
                        </li>
                        <li>
                            The Resource Record (RR). This is always SOA.
                        </li>
                        <li>
                            The Origin Server, i.e. the server from which information is obtained, i.e. the master server for this domain.
                        </li>
                        <li>
                            The Contact is the administrative contact for the domain name (replace the first dot with a @).
                        </li>
                    </ul>
                </p>
                <div class="center figure">
                    <img src="images/DNS_04_23/DNS6.png" width="65%" />
                </div><br />
                <p>
                    Let's use the dig utility to display an example:
                </p>
                <div class="code_content">
                    <code>

                        sudo apt-get install dnsutils<br />

                    </code>
                </div><br />
                <div class="code_content">
                    <code>

                        dig google.com SOA<br />
                        <output>
                            >> [...]<br />
                            >> ;; ANSWER SECTION:<br />
                            >> <mark>google.com.		46	IN	SOA	ns1.google.com. dns-admin.google.com.</mark> 526255916 900 900 1800 60<br />
                            >> [...]
                        </output>

                    </code>

                </div>
                <br /><br />
                <h4>
                    <u>(A) Address records (and AAAA records)</u>

                </h4>
                <p>
                    The Address Record (A record) maps a FQDN to an IPv4 address. AAAA records are for a newer type of IP addressing called IPv6. Remember, the same FQDN can point to multiple addresses.
                </p>
                <p>We can use the dig utility to display an example of A and AAAA records. Let's see how:</p>



                <div class="code_content">
                    <code>

                        dig google.com +noall +answer<br />
                        <output>
                            >> <mark>google.com.		114	IN	A	142.250.180.174</mark>

                        </output>

                    </code>
                </div><br />

                <p>
                    As you can see, the format of the output is aligned to what we’ve previously shown in figure. An AAAA record looks pretty much the same but
                    will display a IPv6 address.
                </p>
                <br />

                <h4>
                    <u>(CNAME) Canonical Name records</u>

                </h4>
                <p>
                    Instead of mapping a FQDN to an address, Canonical Name (CNAME) records map one FQDN to another FQDN. So Canonical Names are just aliases.
                </p>
                <p>
                    So a CNAME points us to another FQDN which must have (even if not necessarily in the same zone file) a valid A record.<br />
                    Take a look at the example of output below:
                </p>



                <div class="code_content">
                    <code>

                        <output>
                            >> www.whatever.com.  3600  IN  CNAME  <mark>mail.whatever.com.</mark><br />
                            [...]<br />
                            >> <mark>mail.whatever.com.</mark>  3600  IN  A  10.10.100.102


                        </output>


                    </code>

                </div>
                <br />
                <br />

                <h4>
                    <u>(MX) Mail Exchanger record</u>

                </h4>
                <p>
                    The Mail Exchanger (MX) record are used by SMTP servers to discover the address of the hosts where emails for a domain should be sent. Note that such hosts can be inside or outside the domain. Here you have an example:
                </p>


                <div class="code_content">
                    <code>

                        <output>
                            >> google.com.		136	IN	MX	<mark>10</mark>   smtp.google.com.

                        </output>

                    </code>
                </div><br />
                <p>
                    That “10” value is a the weight of the record (a peculiarity of MX records) and it expresses a measure of preference in case of multiple MX records. The lower the weight, the higher the preference.
                </p>
                <br />

                <h4>
                    <u>(NS) Name Server record</u>
                </h4>
                <p>
                    In the zone file, NS or Name Server records list the authoritative name servers for a domain. An example of such records is shown below:
                </p>
                <div class="code_content">
                    <code>
                        dig google.com ns<br />
                        <output>
                            >> google.com.		7104	IN	NS	ns2.google.com.
                        </output>
                    </code>
                </div><br />
                <p>
                    Some additional details: (1) A NS must display a FQDN (not an IP address). The FQDN will point to an existing A record; (2) The FQDN displayed does not necessarily belong to the same zone file (it can also point to other hosts).
                </p><br />

                <h4>
                    <u>(PTR) Pointer record</u>
                </h4>
                <p>
                    Pointer records map IP Addresses to names, hence doing the opposite of A records. We are not going to elaborate on these. Just know that an IP Address can only point to a single hostname.
                </p>
                <br />
                <h4>
                    <u>
                        (SRV) Server records
                    </u>
                </h4>
                <p>
                    Let’s say we want to access a certain service for a domain. For that, we need to know the corresponding hostname. But how can we be sure that, having the hostname, it will support the service we want to access? Instead of guessing, we can look at SRV records. The format of SRV is peculiar:
                </p>
                <p>
                    _service._proto.name.  TTL  class  type  priority  weight  port  hostname.
                </p>
                <p>
                    For example:
                </p>
                <div class="code_content">
                    <code>
                        <output>
                            >> http.tcp.www.nothing.com. IN SRV 10 5 80 host1.nothing.com.
                        </output>
                    </code>
                </div>
                <br /><br />
                <h4>
                    <u>
                        (TXT) Text records
                    </u>
                </h4>
                <p>
                    TXT records keep track of some human-readable information about a domain. They look like this:
                </p>
                <div class="code_content">
                    <code>
                        <output>
                            >> google.com.	1924	IN	TXT	<mark>"some text here"</mark>
                        </output>
                    </code>
                </div>
                <p>
                    Remember this type of records, since malware might abuse of such DNS feature by embedding data and commands in DNS queries as TXT records.
                </p>

                <hr /><br />
                <div class="center title_icon">
                    <img src="images/SE.png" width="10%" />

                </div>

                <h3 class="titleh" id="part2">DNS and Social Engineering</h3>
                <p>
                    <strong>Attacker’s goal</strong>: Exploiting social engineering tactics to gain access to a DNS server and change records (e.g. change A records to redirect users towards a malicious server).
                </p>
                <p>
                    Most of us are already imagining sci-fi cyberpunk mysterious hackers trying to infiltrate into servers while wearing a hoodie. But it could be much simpler than that. Social engineering techniques could be deployed by anyone against domain registrars (companies managing the reservation of domain names and establishing NS records in the server of the parent domain), tricking them into changing records and configurations. For example, the attacker could:
                </p>
                <p>
                    <ol>
                        <li>Use the <strong>whois command</strong> (sudo apt-get install whois) to gather information about a domain</li>
                        <li>Look within the output to find out what is the registrar for the domain and what are its <strong>contact details</strong></li>
                        <li>Contact the registrar’s staff and use some manipulative tricks to <strong>convince them to make some changes</strong> to the records (e.g. “<em>I am the new DNS administrator for the company…</em>”). A pretty effective technique (the same deployed by most ransomwares around), is to force the victim into perceiving a strong need for immediate reaction (e.g. “<em>We are suffering from a massive DDoS attack, you are the only one that can save us!”</em>).  </li>
                    </ol>
                </p>
                <p>
                    To prevent this, customers can ask their registrar to configure some <strong>Client EPP (Extensible Provisional Protocol) codes</strong>, including:
                </p>
                <p>
                    <ul>
                        <li>
                            <strong>clientTransferProhibited</strong>: The domain’s registry will reject requests to transfer the domain from the current registrar to another.
                        </li>
                        <li>
                            <strong>serverDeleteProhibited</strong>: Which makes the domain not eliminable.
                        </li>
                        <li>
                            <strong>clientUpdateProhibited</strong>: No change at all can be imposed on the domain, even by authorized agents. Changes are still possible through asking the registrar to deactivate this configuration, which usually requires some strong authentication mechanism.
                        </li>
                    </ul>
                </p>
                <p>
                    As a rule, any relevant change should follow a predefined and well-documented authorization procedure.
                </p>
                <hr />
                <br />
                <div class="center title_icon">
                    <img src="images/poison.png" width="10%" />

                </div>
                <h3 class="titleh" id="part3">DNS Cache Poisoning</h3>
                <p>
                    Here we focus on: (1) Recursive DNS cache poisoning and (2) Local DNS cache poisoning... Obviously, the
                    first type of attack allows for a much broader reach than the second.
                </p>

                <h4><u>Recursive Server Cache Poisoning</u></h4>
                <p>
                    <strong>Attacker’s goal</strong>: load malicious entries into a recursive DNS server’s cache to compromise its behavior.
                </p>
                <p>
                    Let’s start by understanding what the <strong>DNS packet structure</strong> is:
                </p>
                <div class="center">
                    <img src="images/DNS_04_23/DNS8.png" width="300px" />

                </div>
                <br />
                <p>
                    Let’s focus on header, question and answer. Knowing that everything is done through UDP, the
                    maximum packet size is 512. The header has a length of 12 bytes. Question and answer sections
                    vary in size.
                    Now, because of UDP being connectionless, there’s no handshake between authoritative and recursive
                    servers. Instead, they manage to keep track of the conversation by using as reference the combination
                    of <strong>(A) source port, (B) original destination IP address, (C) a 16-bit transaction ID</strong>.
                </p>
                <p>
                    To <strong>forge a DNS packet</strong>, A. Liska and G. Stowe suggest to use the <strong>hping3</strong> utility. With the following command, we can craft and send DNS packets to the recursive server using the spoofed IP address of the authoritative one as origin.
                </p>
                <div class="code_content">
                    <code>
                        hping3  -2  -p 53  --spoof  <variab>AUTHOR_SERVER_IP_ADDRESS  RECURS_SERVER_IP_ADDRESS</variab>
                    </code>
                </div>
                <br />
                <p>
                    -2 expresses the protocol selection for UDP, -p 53 sets the destination port to 53 (used by DNS), -spoof sets the fake IP address.
                </p>
                <p>
                    Assuming that the port was indeed set to 53 (not necessarily true), the only thing that we still need to figure out to hijack the
                    communication between the two servers is the 16-bit transaction ID. The right 16-bit ID is one out of 65535 possible (2<sup>16</sup>)
                    combinations. When the recursive server will query the authoritative one, the attacker will flood the recursive server
                    with lots of forged responses (having as source the spoofed IP address of the authoritative server). Each forged response
                    will contain a <strong>guessed transaction ID</strong>. For the poisoning to be successful, only one match is needed. The point is that the
                    match must be found before the response from the authentic authoritative server reaches the recursive one. A. Liska and G. Stowe
                    also explain how the attacker might want to increase his/her chances in guessing the right transaction ID by querying multiple
                    times the recursive server for random inexistent subdomains while forging fake responses. If you want to have more details about how it's done, buy
                    their book cited in the bibliography section :D.
                </p>
                <br />
                <h4><u>Local DNS Cache Poisoning</u></h4>
                <p>
                    Earlier we said that your OS also keeps a small <strong>local cache</strong> of recently resolved FQDNs. The purpose of this cache is to allow you to reach out frequently asked domain names faster. Of course, also this cache can be poisoned.
                    In fact, our computer will first check for the mapping of a domain name in the local cache and then – if necessary – ask for help through the resolution process described above. Changing such local cache will lead to the same result seen above. In this case though, <strong>the poisoning is limited to the one targeted host </strong>.

                </p>
                <hr />
                <br />
                <div class="center title_icon">
                    <img src="images/spoof.png" width="10%" />

                </div>
                <h3 class="titleh" id="part4">DNS Spoofing</h3>
                <p>
                    Wikipedia defines a <strong>spoofing attack</strong> as “the situation in which a person or program successfully identifies as another by falsifying data, to gain an illegitimate advantage”. We have just seen that DNS poisoning involves DNS spoofing. Let’s give a brief description of some other cases of spoofing:
                </p>
                <h4><u>Targeting the <em>hosts</em> file</u></h4>
                <p>
                    The <strong> host file </strong> is a plain text file that contains mappings of domain names and IP
                    addresses. The hosts file allowed resolution before the DNS came around, but it still present in our
                    operating systems. You can find it at: c:\Windows\System32\Drivers\etc\hosts (Windows) or at /etc/hosts
                    (Linux). Contents of the hosts file will be <strong>used preferentially</strong> to other resolution
                    methods, such as DNS.
                </p>
                <p>
                    A. Liska and G. Stowe tell us the tale of the <strong>Win32.QHOST Trojan</strong> (first reported in 2000). Without getting into details, the malware would change the content of the hosts file, mapping the domain names of dozens of the most famous security vendors to the <strong>loopback address 127.0.0.1.</strong> Since all packets destined to the loopback address are routed back to the same device where it originated, Win32.QHOST hosts to interact with security applications (for example, to get signature updates).

                </p>
                <br />
                <h4><u>DNS Spoofing in a MITM half duplex fashion </u></h4>
                <p>
                    Assume that the attacker has already access to the targeted network. In such case, he might want to use a <strong>sniffer</strong>. Assume that he can use it without being detected. The attacker will be able to eavesdrop the DNS requests and quickly respond accordingly, while pretending to be the recursive server. If the forged response reaches the target host before the legitimate one, the attack is successful.
                    We can call this <strong>Man-in-the-middle half duplex</strong>, since the communication is manipulated only in one of the two directions.
                </p>
                <p>
                    Notice how this <strong>differs from poisoning</strong>, since being able to eavesdrop DNS requests will save us the trouble of having to guess the transaction ID.
                </p>
                <p>
                    A useful tool to do this is
                    <a href="https://linux.die.net/man/8/dnsspoof"><strong>dnsspoof</strong></a>.
                </p>
                <hr />


                <br />
                <div class="center title_icon">
                    <img src="images/ddos.png" width="10%" />

                </div>
                <h3 class="titleh" id="part5">DDoS through DNS</h3>
                <h4><u>Collaborative and intentional DDoS </u></h4>
                <p>
                    <strong>Attacker’s goal</strong>: flood the victim server with more traffic than it can process until the server goes down.
                </p>
                <p>
                    Note that many tools exist to carry out a voluntary DDoS attack, for example the open-source <strong>Low Orbit Ion Cannon</strong> application (frequently used by Anonymous). When similar tools are deployed, users are aware of what they are doing and they willingly initiate the attack (DDoS through botnets are another story). Moreover, attackers’ IP addresses are generally traceable.
                </p>
                <br />
                <h4><u>DNS Amplification and Reflection </u></h4>
                <p>
                    <strong>Attacker’s goal</strong>: instruct botnets to craft small DNS queries that trigger really large responses (<u>amplification</u>) and direct such heavy traffic towards a victim machine by using its spoofed IP address as the source of the queries (<u>reflection</u>).
                </p>
                <p>
                    To craft such queries, use the dig command:
                </p>
                <div class="code_content">
                    <code>
                        dig @DNS-server-name domain-name  ANY 1 dnssec
                    </code>
                </div>
                <br />
                <p>
                    … Where @ is followed by the DNS server name to which the query is directed and the domain name for which DNS information is being requested. ANY means we are asking for any record. 1 means that if the initial query fails, no further attempts will be made. dnssec is asking for DNSSEC (Domain Name System Security Extensions) information for the specified domain. But don’t worry about the details, the point is that this is a small query which will return a lot. The amplification part is done.
                </p>
                <p>
                    For the reflection attack, the authors suggest to capture the packet generated by the query and copy it into a query.txt file. Then, by using hping3, we can spoof the IP address of the victim and craft a new packet carrying the content of query.txt
                </p>
                <div class="code_content">
                    <code>
                        hping3 -2 -p 53 -E <variab>…/query.txt </variab>-d 40 --spoof <variab>victim-ip-address</variab>
                    </code>
                </div>
                <br />
                <p>
                    -E tells us that the content of query.txt will be sent in the packet. -d 40 sets the size of the data to 40 bytes.
                </p>
                <p>
                    For a more detailed demonstration of this, check out the resource <strong>“DNS Security: Defending the Domain Name System”</strong>and support the authors!
                </p>
                <hr />
                <br />






















            </div>  <! -- End of textual content -->


            <br />


        </div>
        <a href="#bibliography" class="top">Back to Top</a>





    </div>




    </div>
    </div>

    <div class="bottom">
        Free icons from <a href="https://www.flaticon.com/"><u>flaticon.com</u></a>
        <br />
        Built by <strong><a href="contacts.html">Jacopo Grassi</a></strong>
        <br />
        2023
    </div>

</body>
</html>